Routes for testing:
- all routes are defined in App.js (with React Router)

1. Shop routes:

http://localhost:3000 - Home.jsx
http://localhost:3000/account - Account.jsx
http://localhost:3000/cart - Cart.jsx
http://localhost:3000/products - ProductsList.jsx
http://localhost:3000/products/460 - Product.jsx (with ID = 460) -> route contains a dynamic parameter (ID of the product)
http://localhost:3000/delivery - Delivery.jsx
http://localhost:3000/payment - Payment.jsx 


2. Admin routes:

http://localhost:3000/admin/ - AdminStats.jsx
http://localhost:3000/admin/products - AdminProducts.jsx
http://localhost:3000/admin/orders - AdminOrders.jsx


3. Error route:

http://localhost:3000/something - Error.jsx (any undefined path after http://localhost:3000/...)


Layouts / wrappers:

RootLayout.jsx - wrapping all Shop-routes, and already contains Header.jsx & Footer.jsx (no need to add them to each page).

AdminLayout.jsx - wrapping all Admin-routes, and already contains AdminHeader.jsx & AdminFooter.jsx.


--------------------------------

Product categories:

1 Desks

2 Chairs

3 Organizers

4 Electronics

5 Clocks

6 Lighting

7 Mouse Pads

8 Drinkware

9 Decorations

10 The Office Tribute / Tribute

--------------------------------------------------------------

Passing the prop (selectedCategory):

1. RootLayout:

const [selectedCategory, setSelectedCategory] = useState(null);

- setter-function 'setSelectedCategory'-state is passed to Header.jsx (= child-component of RootLayout):

<Header onSelectCategory={setSelectedCategory} />
<Outlet context={{ selectedCategory }}/>           // (Outlet = placeholder for main content of each page wrapped with Rootlayout)

2. Header:

- setter-function 'setSelectedCategory' is recieved via prop 'onSelectCategory' and passed further to CategoriesBox.jsx (= child-component of Header):

export default function Header({ onSelectCategory }) {
  <CategoriesBox onSelectCategory={onSelectCategory} />
}

3. CategoriesBox:

- fetching all categories-names from backend:
const res = await axios.get(`${process.env.REACT_APP_API_URL}/api/categories`);
setCategories(res.data.data);

export default function CategoriesBox({ onSelectCategory }) {
  <button onClick={() => onSelectCategory(i + 1)}>Category {i+1}</button>
  OR LATER (instead just number for each category -> category names)
   <button onClick={() => onSelectCategory(categ.category_id)}>Category {categ.category_name}</button>
}

- setter-function is called on click, and is taking value (selected category-button)


--------------------------------------------------------------------------------------

Fetching all products from one category:

CategoryItems.jsx:

// state for collecting all items/products of one category:
const [items, setItems] = useState([]);

const res = await axios.get(`${process.env.REACT_APP_API_URL}/api/items/category/${categoryId}`);
setItems(res.data.data);

-> map()-function to fetch all attributes of each fetched product as props, then pass and display them in ItemCard.jsx for each product.

- contains a loader, spinning while products are being fetched:

  const [loading, setLoading] = useState(false);

- CategoryItems-component is included on ProductsList-page - which renders whenever user wants to fetch products based on some category, filter? etc.

--------

ProductsList-page:

- is consuming context (selectedCategory), as one of the pages wrapped with Rootlayout:

  const { selectedCategory } = useOutletContext();

-----------------------------------------------------------

Clicking on specific ItemCard and passing it's ID:


ProductsList.jsx: 

- adds prop 'onItemSelected' to it's child-component <CategoryItems>, the prop is containing 'id' (of the selected product)

CategoryItems.jsx

- accepts prop 'onItemSelected' from the parent ProductsList-page, and tracks state for 'ItemCardClicked':

  const [ItemCardClicked, setItemCardClicked] = useState(null);

  function handleItemCardClick(itemId) {
    setItemCardClicked(itemId);
    console.log("Clicked product id:", itemId);
    if (onItemSelected) {
      onItemSelected(itemId); // sending ID to the parent-component
    }
  }

  <ItemCard /other props.../  onClick={() => handleItemCardClick(item.item_id)}>
  // taking itemId of the clicked ItemCard as argument & setting it to the state 'ItemCardClicked', just passing function, not calling it

ItemCard.jsx

- adding onClick prop to the props list:
export default function ItemCard({name, description, price, discountPrice, quantity, picture, category, tags, className, onClick })

- adding onClick prop to the whole section - reacting when the whole section, wrapping element / the card is clicked:
 return (
    <section className={className} onClick={onClick}>
      <div className="item-image">
  ...)


---------------------------------------------------------------------------------------------------------------------------

*** using React Query / Tanstack for server state (data fetched from API)
- advantages: caching, refetching, loading/error state out‑of‑the‑box.

Product.jsx - React Query:

const { id } = useParams();
  // fetching ID from the http-link:  http://localhost:3000/products/24 -> id='24'

  const {data: product, isLoading, isError} = useQuery({
    queryKey: ["product", id],         // unique key for caching data
    queryFn: async () => {             // query-function, API-request for data
      const res = await axios.get(      
        `${process.env.REACT_APP_API_URL}/api/items/${id}`
      );
      return res.data.data;
    },
  });
if (isLoading) return <div className="loader">Loading product...</div>;
if (isError) return <div>Error loading product</div>;
if (!product) return <div>Product not found</div>;

return( <ProductSection product={product} />)


CategoryItems.jsx - React Query:

export default function CategoryItems({ categoryId, onItemSelected }) {
  const { data: items = [], isLoading } = useQuery({
    queryKey: ["items", categoryId],   // unique key for caching data
    queryFn: async () => {             // query-function, API-request for data
      const res = await axios.get(
        `${process.env.REACT_APP_API_URL}/api/items/category/${categoryId}`
      );
      return res.data.data;
    },
    enabled: !!categoryId, 
  });

  if (isLoading) return <div className="loader"></div>;
  if (items.length === 0) return <p className="div-center">No items in this category</p>;

  return (<ItemCard /...other props.../ onClick={() => onItemSelected(item.item_id)}>)
}


----------------------------------------------------------------------------------------------------------------------------

*** using Redux Toolkit for: global state (e.g. user session, cart, UI state)
- advantages: centralized store, easy data sharing between components


**Add to Cart - saves Product ID & Quantity into state - global state (Redux toolkit) 
-> state is passed to CartMain, and then CartMain is used on parent-page Cart, and in parent-components: CartModal 


*** Update: Cart state is managed via React Context, and kept in context-store -> CartContext.jsx

- useReducer is used for more complex state, + 2 action-types: 'ADD_ITEM', 'REMOVE_ITEM'
- ContextProvider is wrapped arround all pages in App.js

Next: 
add this functionallity to ItemCard.jsx, onClick -> add to Cart, 
also develop Cart-page and add add/remove functionallities there. 


Cart.jsx - page contains: 

  CartMain.jsx - component, which uses cart-context: 

const cartCtx = useContext(CartContext);

Then it maps through each item of the cartCtx, and for each item it renders a <li>, containing item-name, image, price, quantity.
<ul>
    {cartCtx.items.map((item) => (
        <li key={item.item_id} className="cart-item"> 
... ) ) }

In the end, CartMain.jsx shows Total price, and a button to Proceed to payment. 

-----------------------------------------

Showing Toastify-confirmation when an item is added to Cart:

ToastContainer is imported to RootLayout-component, so toast-notifications can be used in all child-components.
Added toast to ItemCard, it is called inside of handleAddToCart()-function, whenever “Add to Cart” button is pressed. 

toast(
      <div>
        <span className="checkmark">✓</span>  <span className="toast-itemname">{name}</span> added to cart
      </div>
    );

Also added catch-error notification to ItemCard, if item cannot be added 
(test: simply comment out this line in CartContext: addItem: addItem, - so adding will not be possible).

-------------------

To do:

+ u Toast notifikacije u ItemCard dodati u zagradu (item.quantity), nakon item.name.

- Proceed to payment button u CartMain se prikazuje samo ako ima barem 1 item. Ako je cart prazan, onda ne treba ni button biti vidljiv. 

- dodati Home button

- dodati Footer

- sortiranje, filtriranje, searchanje

- login-Modal za username & password

- login/logout-state spremljen preko Reduxa

- Account-page za Sign up (kreiranje i izmjenu accounta)

- spremanje Accounta svakog usera u bazu i fetchanje podataka radi izmjena

- spremanje podataka o orderu produkata (Cart) u bazu (da se ne gube kod refresha stranice)

- povezivanje ordera, accounta i proizvoda u bazi